---
// Racing Game Component
---

<div class="race-game-container">
  <h3 class="race-title">
    üèéÔ∏è BONUS: REVANCHA EN LAS PISTAS üí®
  </h3>
  <p style="text-align: center; margin-bottom: 1.5rem;">
    Ya que me humillaste 2 veces en el Quicentro...<br>
    <strong class="text-pink">¬øLista para la tercera ronda?</strong><br>
    <small style="color: var(--color-gray);">(Llega a 200 puntos para desbloquear el mensaje final)</small><br>
    <small style="color: var(--color-gray);">Controles: WASD o Flechas (PC) | Toca lados (M√≥vil)</small>
  </p>
  
  <div style="text-align: center;">
    <button id="start-race-btn" class="btn btn--yellow">
      üèÅ INICIAR REVANCHA
    </button>
  </div>
  
  <canvas 
    id="raceCanvas" 
    width="600" 
    height="400"
    style="display:none; width:100%; max-width: 600px; margin: 1.5rem auto; background:#0a0a0a; display: block; border: 4px solid var(--color-black); box-shadow: var(--shadow-comic);"
  ></canvas>
   
  <p id="game-instructions" 
    style="display:none; font-size:0.9em; color: var(--color-pink); margin-top: 1rem; text-align: center; font-weight: bold;">
    ‚å®Ô∏è CONTROLES: W/A/S/D o Flechas ‚Üê ‚Üí (PC) | Toca Izquierda/Derecha (M√≥vil)
  </p>
</div>

<style>
  .race-game-container {
    background: var(--color-white);
    border: 5px dashed var(--color-cyan);
    padding: var(--space-xl);
    margin-top: var(--space-xxl);
  }
  
  .race-title {
    color: var(--color-pink);
    font-family: var(--font-ui);
    text-align: center;
    font-size: 1.8em;
    text-shadow: 3px 3px 0 var(--color-black);
    margin-bottom: var(--space-md);
  }
  
  #raceCanvas {
    border-radius: 8px;
  }
  
  @media (max-width: 768px) {
    .race-game-container {
      padding: var(--space-lg);
    }
  }
</style>

<script>
  // Car Race Game
  const startBtn = document.getElementById('start-race-btn');
  const canvas = document.getElementById('raceCanvas') as HTMLCanvasElement;
  const instructions = document.getElementById('game-instructions');
  
  if (!startBtn || !canvas) {
    console.error('Race game elements not found');
  } else {
    let gameRunning = false;
    const ctx = canvas.getContext('2d')!;
    
    // Game State
    interface Car {
      x: number;
      y: number;
      w: number;
      h: number;
      color: string;
      speed: number;
    }
    
    interface Obstacle extends Car {}
    
   let car: Car = { x: 280, y: 340, w: 40, h: 70, color: '#FF0055', speed: 0 };
    let obstacles: Obstacle[] = [];
    let score = 0;
    let gameSpeed = 4;
    let animationId: number;
    let roadOffset = 0;
    
    startBtn.addEventListener('click', () => {
      if (gameRunning) return;
      canvas.style.display = 'block';
      if (instructions) instructions.style.display = 'block';
      startBtn.style.display = 'none';
      startGame();
    });
    
    function startGame() {
      gameRunning = true;
      score = 0;
      obstacles = [];
      gameSpeed = 4;
      car.x = canvas.width / 2 - car.w / 2;
      roadOffset = 0;
      
      document.addEventListener('keydown', handleInput);
      canvas.addEventListener('touchstart', handleTouch);
      canvas.addEventListener('click', handleTouch);
      
      loop();
    }
    
    function handleInput(e: KeyboardEvent) {
      if (!gameRunning) return;
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') car.x -= 35;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') car.x += 35;
      car.x = Math.max(100, Math.min(car.x, canvas.width - 100 - car.w));
      playEngineSound();
    }
    
    function handleTouch(e: MouseEvent | TouchEvent) {
      if (!gameRunning) return;
      const rect = canvas.getBoundingClientRect();
      const clientX = e instanceof MouseEvent ? e.clientX : e.touches[0].clientX;
      const clickX = clientX - rect.left;
      
      if (clickX < canvas.width / 2) car.x -= 35;
      else car.x += 35;
      
      car.x = Math.max(100, Math.min(car.x, canvas.width - 100 - car.w));
      playEngineSound();
    }
    
    function loop() {
      if (!gameRunning) return;
      
      // Animated Road
      roadOffset += gameSpeed;
      if (roadOffset > 40) roadOffset = 0;
      
      // Clear with gradient
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#050505');
      gradient.addColorStop(1, '#0a0a0a');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw Road Lines
      ctx.strokeStyle = '#1a1a1a';
      ctx.lineWidth = 2;
      for (let i = -1; i < canvas.height / 40 + 1; i++) {
        let y = i * 40 - roadOffset;
        ctx.beginPath();
        ctx.moveTo(100, y);
        ctx.lineTo(canvas.width - 100, y);
        ctx.stroke();
      }
      
      // Road Edges
      ctx.strokeStyle = '#FF0055';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(100, 0);
      ctx.lineTo(100, canvas.height);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(canvas.width - 100, 0);
      ctx.lineTo(canvas.width - 100, canvas.height);
      ctx.stroke();
      
      // Center Line
      ctx.setLineDash([20, 10]);
      ctx.strokeStyle = '#00F0FF';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 0);
      ctx.lineTo(canvas.width / 2, canvas.height);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Spawn Obstacles
      if (Math.random() < 0.03) {
        const lanes = [150, 280, 410];
        obstacles.push({
          x: lanes[Math.floor(Math.random() * lanes.length)],
          y: -70,
          w: 40,
          h: 70,
          color: Math.random() > 0.5 ? '#00F0FF' : '#9D00FF',
          speed: 0
        });
      }
      
      // Update and Draw Obstacles
      obstacles.forEach((obs, index) => {
        obs.y += gameSpeed;
        
        // Draw obstacle
        ctx.fillStyle = obs.color;
        ctx.shadowBlur = 15;
        ctx.shadowColor = obs.color;
        ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
        ctx.fillStyle = '#000';
        ctx.fillRect(obs.x + 5, obs.y + 15, obs.w - 10, 20);
        ctx.fillRect(obs.x + 5, obs.y + 45, obs.w - 10, 15);
        ctx.shadowBlur = 0;
        
        // Collision
        if (
          car.x < obs.x + obs.w &&
          car.x + car.w > obs.x &&
          car.y < obs.y + obs.h &&
          car.y + car.h > obs.y
        ) {
          gameOver();
        }
        
        // Remove off screen
        if (obs.y > canvas.height) {
          obstacles.splice(index, 1);
          score++;
          if (score % 10 === 0) {
            playScoreSound();
            gameSpeed += 0.5;
          }
        }
      });
      
      // Draw Player Car
      ctx.fillStyle = car.color;
      ctx.shadowBlur = 25;
      ctx.shadowColor = car.color;
      ctx.fillRect(car.x, car.y, car.w, car.h);
      ctx.fillStyle = '#EAEAEA';
      ctx.fillRect(car.x + 5, car.y + 10, car.w - 10, 20);
      ctx.fillRect(car.x + 5, car.y + 40, car.w - 10, 20);
      ctx.fillStyle = '#00F0FF';
      ctx.fillRect(car.x - 5, car.y + car.h - 5, car.w + 10, 5);
      ctx.shadowBlur = 0;
      
      // HUD
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 24px Roboto Mono';
      ctx.fillText('SCORE: ' + score, 15, 35);
      ctx.font = '16px Roboto Mono';
      ctx.fillStyle = '#00F0FF';
      ctx.fillText('META: 200', canvas.width - 120, 35);
      ctx.fillStyle = '#FF0055';
      ctx.font = '14px Roboto Mono';
      ctx.fillText('SPEED: ' + Math.floor(gameSpeed * 10), 15, 60);
      
      // Win condition
      if (score >= 200) {
        gameWin();
        return;
      }
      
      animationId = requestAnimationFrame(loop);
    }
    
    function gameOver() {
      gameRunning = false;
      playCrashSound();
      
      ctx.fillStyle = 'rgba(0,0,0,0.85)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.textAlign = 'center';
      ctx.fillStyle = '#FF0055';
      ctx.font = 'bold 36px Syncopate';
      ctx.fillText('¬°CHOQUE!', canvas.width / 2, canvas.height / 2 - 20);
      
      ctx.font = '18px Roboto Mono';
      ctx.fillStyle = '#fff';
      ctx.fillText('Puntos: ' + score, canvas.width / 2, canvas.height / 2 + 20);
      
      ctx.font = '16px Michroma';
      ctx.fillStyle = '#00F0FF';
      ctx.fillText('Click para reintentar', canvas.width / 2, canvas.height / 2 + 50);
      
      canvas.addEventListener('click', restartGame, { once: true });
    }
    
    function restartGame() {
      canvas.removeEventListener('click', restartGame);
      startGame();
    }
    
    function gameWin() {
      gameRunning = false;
      playWinSound();
      
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.textAlign = 'center';
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 32px Syncopate';
      ctx.fillText('¬°VICTORIA!', canvas.width / 2, canvas.height / 2 - 60);
      
      ctx.fillStyle = '#FF0055';
      ctx.font = 'bold 26px Michroma';
      ctx.fillText('¬°FELICIDADES MAJITO!', canvas.width / 2, canvas.height / 2 - 20);
      
      ctx.fillStyle = '#00F0FF';
      ctx.font = '18px Roboto Mono';
      ctx.fillText('Espero que esta web no se te haga', canvas.width / 2, canvas.height / 2 + 20);
      ctx.fillText('muy "nerd" y que al menos sirva', canvas.width / 2, canvas.height / 2 + 45);
      ctx.fillText('para sacarte una risa üèéÔ∏èüí®', canvas.width / 2, canvas.height / 2 + 70);
      
      ctx.font = '14px Michroma';
      ctx.fillStyle = '#888';
      ctx.fillText('(Click para volver a jugar)', canvas.width / 2, canvas.height / 2 + 105);
      
      canvas.addEventListener('click', restartGame, { once: true });
    }
    
    // Audio functions
    function playEngineSound() {
      const audioCtx = new (window.AudioContext || (window as any).webkitAudioContext)();
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.frequency.value = 80;
      osc.type = 'sawtooth';
      gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.05);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.05);
    }
    
    function playCrashSound() {
      const audioCtx = new (window.AudioContext || (window as any).webkitAudioContext)();
      [100, 80].forEach((freq, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.frequency.value = freq;
        osc.type = i === 0 ? 'sawtooth' : 'square';
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.5);
      });
    }
    
    function playScoreSound() {
      const audioCtx = new (window.AudioContext || (window as any).webkitAudioContext)();
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.frequency.value = 600;
      osc.type = 'sine';
      gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.1);
    }
    
    function playWinSound() {
      const audioCtx = new (window.AudioContext || (window as any).webkitAudioContext)();
      [500, 600, 800].forEach((freq, i) => {
        setTimeout(() => {
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.frequency.value = freq;
          osc.type = 'sine';
          gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
          osc.connect(gain);
          gain.connect(audioCtx.destination);
          osc.start();
          osc.stop(audioCtx.currentTime + 0.4);
        }, i * 100);
      });
    }
  }
</script>
